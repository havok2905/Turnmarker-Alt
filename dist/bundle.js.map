{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://turnmarker-alt/./src/utils.js","webpack://turnmarker-alt/./src/marker.js","webpack://turnmarker-alt/./src/markeranimation.js","webpack://turnmarker-alt/./src/settingsForm.js","webpack://turnmarker-alt/./src/settings.js","webpack://turnmarker-alt/./src/chatter.js","webpack://turnmarker-alt/./src/turnmarker.js","webpack://turnmarker-alt/./src/updateWindow.js"],"sourcesContent":["\n/**\n * The name of the module\n */\nexport const modName = 'turnmarker';\n\n/** Socket Info */\nexport const socketName = `module.${modName}`;\nexport const socketAction = {\n    deleteStartMarker: 1,\n    deleteTurnMarker: 2,\n    deleteOnDeckMarker: 3\n};\n\n/**\n * Returns a token object from the canvas based on the ID value\n * @param {String} tokenId - The ID of the token to look for\n */\nexport function findTokenById(tokenId) {\n    return canvas.tokens.ownedTokens.find(t => t.id == tokenId);\n}\n\n/**\n * Returns a tile object from the canvas based on the ID value; mostly for debugging\n * @param {String} tileId - The ID of the token to look for\n */\nexport function findTileById(tileId) {\n    return canvas.background.tiles.find(t => t.id == tileId);\n}\n\n/**\n * Returns the ID of the first user logged in as GM.\n * Use for actions that need to be done by a GM but by only 1 GM\n */\nexport function firstGM() {\n    for (let user of game.users.contents) {\n        if (user.role === CONST.USER_ROLES.GAMEMASTER && user.active) {\n            return user.id;\n        }\n    }\n    return undefined;\n}\n\n/**\n * Returns the index of the nextTurn\n * @param {Object} combat - combat object from foundry\n */\nexport function getNextTurn(combat) {\n    return (combat.turn + 1) % combat.turns.length;\n}\n\n/**\n * Delete time\n * @param {Object} combat - combat object from foundry\n */\nexport async function deleteTile({ mode } = {}) {\n    let tiles = null\n    switch (mode) {\n        case socketAction.deleteStartMarker:\n            tiles = canvas.scene.getEmbeddedCollection('Tile')?.filter(t => t.flags?.startMarker === true)?.map(t => t.id)\n            if (tiles?.length > 0) {\n                await canvas.scene.deleteEmbeddedDocuments('Tile', tiles)\n            }\n            break\n        case socketAction.deleteTurnMarker:\n            tiles = canvas.scene.getEmbeddedCollection('Tile')?.filter(t => t.flags?.turnMarker === true)?.map(t => t.id)\n            if (tiles?.length > 0) {\n                await canvas.scene.deleteEmbeddedDocuments('Tile', tiles)\n            }\n            break\n        case socketAction.deleteOnDeckMarker:\n            tiles = canvas.scene.getEmbeddedCollection('Tile')?.filter(t => t.flags?.deckMarker === true)?.map(t => t.id)\n            if (tiles?.length > 0) {\n                await canvas.scene.deleteEmbeddedDocuments('Tile', tiles)\n            }\n            break\n    }\n}\n","import {Settings} from './settings.js';\nimport {deleteTile, findTokenById, socketAction, socketName} from './utils.js';\n\n/**\n * Provides functionality for creating, moving, and animating the turn marker\n */\nexport class Marker {\n\n    /**\n     * Deletes any tiles flagged as a 'Turn Marker' from the canvas\n     */\n    static async deleteTurnMarker() {\n        if (!game.user.isGM) {\n            game.socket.emit(socketName, {\n                mode: socketAction.deleteTurnMarker\n            });\n        } else {\n            await deleteTile({ mode: socketAction.deleteTurnMarker });\n        }\n    }\n\n    /**\n     * Deletes any tiles flagged as a 'Deck Marker' from the canvas\n     */\n    static async deleteOnDeckMarker() {\n        if (!game.user.isGM) {\n            game.socket.emit(socketName, {\n                mode: socketAction.deleteOnDeckMarker\n            });\n        } else {\n            await deleteTile({ mode: socketAction.deleteOnDeckMarker });\n        }\n    }\n\n    /**\n     * Places a new turn marker under the token specified, and if required, starts the animation\n     * @param {String} tokenId - The ID of the token where the marker should be placed\n     */\n    static async placeTurnMarker(tokenId) {\n        if (game.user.isGM && Settings.getIsEnabled(\"turnmarker\")) {\n            const token = findTokenById(tokenId);\n            if (typeof token !== 'undefined') {\n                let dims = this.getImageDimensions(token, false, \"turnmarker\");\n                let center = this.getImageLocation(token, false, \"turnmarker\");\n                const tile = canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags?.turnMarker === true);\n                const updateData = {\n                    img: Settings.getImagePath(),\n                    width: dims.w,\n                    height: dims.h,\n                    x: center.x,\n                    y: center.y,\n                    z: 900,\n                    rotation: tile ? tile.rotation : 0,\n                    hidden: token.hidden,\n                    locked: false\n                };\n                if (typeof tile === 'undefined') {\n                    await canvas.scene.createEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        flags: { turnMarker: true }\n                    }]);\n                } else {\n                    await canvas.scene.updateEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        _id: tile.id\n                    }]);\n                }\n                return;\n            }\n        }\n        await this.deleteTurnMarker();\n    }\n\n    static async placeOnDeckMarker(tokenId) {\n        if (game.user.isGM && Settings.getIsEnabled(\"deckmarker\")) {\n            const token = findTokenById(tokenId);\n            if (typeof token !== 'undefined') {\n                let dims = this.getImageDimensions(token, false, \"deckmarker\");\n                let center = this.getImageLocation(token, false, \"deckmarker\");\n                let tile = canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags?.deckMarker === true);\n                const updateData = {\n                    img: Settings.getOnDeckImagePath(),\n                    width: dims.w,\n                    height: dims.h,\n                    x: center.x,\n                    y: center.y,\n                    z: 900,\n                    rotation: tile ? tile.rotation : 0,\n                    hidden: token.hidden,\n                    locked: false\n                };\n                if (typeof tile === 'undefined') {\n                    await canvas.scene.createEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        flags: { deckMarker: true }\n                    }]);\n                } else {\n                    await canvas.scene.updateEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        _id: tile.id\n                    }]);\n                }\n                return;\n            }\n        }\n        await this.deleteOnDeckMarker();\n    }\n\n    /**\n     * Deletes any tiles flagged as a 'Start Marker' from the canvas\n     */\n    static async deleteStartMarker() {\n        if (!game.user.isGM) {\n            game.socket.emit(socketName, {\n                mode: socketAction.deleteStartMarker\n            });\n        } else {\n            await deleteTile({ mode: socketAction.deleteStartMarker });\n        }\n    }\n\n    /**\n     * If enabled in settings, place a \"start\" marker under the token where their turn started.\n     * @param {String} tokenId - The ID of the token to place the start marker under\n     */\n    static async placeStartMarker(tokenId) {\n        if (game.user.isGM && Settings.getIsEnabled(\"startmarker\")) {\n            let token = findTokenById(tokenId);\n            if (typeof token !== 'undefined') {\n                let dims = this.getImageDimensions(token);\n                let center = this.getImageLocation(token);\n                let tile = canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags?.startMarker === true);\n                const updateData = {\n                    img: Settings.getStartMarker(),\n                    width: dims.w,\n                    height: dims.h,\n                    x: center.x,\n                    y: center.y,\n                    z: 900,\n                    rotation: 0,\n                    hidden: token.hidden,\n                    locked: false\n                };\n                if (typeof tile === 'undefined') {\n                    await canvas.scene.createEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        flags: { startMarker: true }\n                    }]);\n                } else {\n                    await canvas.scene.updateEmbeddedDocuments('Tile', [{\n                        ...updateData,\n                        _id: tile.id\n                    }]);\n                }\n                return;\n            }\n        }\n        await this.deleteStartMarker();\n    }\n\n    /**\n     * Moves the turn marker tile under the specified token\n     * @param {String} tokenId - The ID of the token that the marker should be placed under\n     * @param {String} markerId - The ID of the tile currently serving as the turn marker\n     * @param {String} marker_type - The marker type\n     */\n    static async moveMarkerToToken(tokenId, markerId, marker_type=\"turnmarker\") {\n        let token = findTokenById(tokenId);\n        if (typeof token !== 'undefined') {\n            let dims = this.getImageDimensions(token, false, marker_type);\n            let center = this.getImageLocation(token, false, marker_type);\n\n            await canvas.scene.updateEmbeddedDocuments('Tile', [{\n                _id: markerId,\n                width: dims.w,\n                height: dims.h,\n                x: center.x,\n                y: center.y,\n                hidden: token.hidden\n            }]);\n        }\n    }\n\n    /**\n     * Removes any existing turn marker and start marker tiles from the canvas\n     */\n    static async clearAllMarkers() {\n        await this.deleteTurnMarker();\n        await this.deleteStartMarker();\n        await this.deleteOnDeckMarker();\n    }\n\n    /**\n     * Updates the tile image when the image path has changed\n     */\n    static async updateImagePath() {\n        if (game.user.isGM) {\n            let tile = canvas.scene.tiles.find(t => t.flags?.turnMarker == true);\n            if (tile) {\n                await tile.update({\n                    _id: tile.id,\n                    img: Settings.getImagePath()\n                });\n            }\n        }\n    }\n\n    /**\n     * Updates the tile image when the image path has changed\n     */\n    static async updateOnDeckImagePath() {\n        if (game.user.isGM) {\n            let tile = canvas.scene.tiles.find(t => t.flags?.deckMarker == true);\n            if (tile) {\n                await tile.update({\n                    _id: tile.id,\n                    img: Settings.getOnDeckImagePath()\n                });\n            }\n        }\n    }\n\n    /**\n     * Gets the proper dimensions of the marker tile taking into account the current grid layout\n     * @param {object} token - The token that the tile should be placed under\n     * @param {Boolean} ignoreRatio - Ignore ratio setting\n     * @param {String} marker_type - The marker type\n     */\n    static getImageDimensions(token, ignoreRatio = false, marker_type = \"turnmarker\") {\n        let ratio = ignoreRatio ? 1 : Settings.getRatio(marker_type);\n        let newWidth = 0;\n        let newHeight = 0;\n\n        switch (canvas.grid.type) {\n            case 2:\n            case 3: // Hex Rows\n                newWidth = newHeight = token.h * ratio;\n                break;\n            case 4:\n            case 5: // Hex Columns\n                newWidth = newHeight = token.w * ratio;\n                break;\n            default: // Gridless and Square\n                newWidth = this.getSmallerDimension(token.w, token.h) * ratio;\n                newHeight = this.getSmallerDimension(token.w, token.h) * ratio;\n                break;\n        }\n\n        return {w: newWidth, h: newHeight};\n    }\n\n    /**\n     * Returns the smaller dimension, so we can prevent lopsided markers when we have larger tokens on square/gridless\n     * @param width\n     * @param height\n     * @returns {*}\n     */\n    static getSmallerDimension(width, height) {\n        return width < height ? width : height;\n    }\n\n    /**\n     * Gets the proper location of the marker tile taking into account the current grid layout\n     * @param {object} token - The token that the tile should be placed under\n     */\n    static getImageLocation(token, ignoreRatio = false, marker_type = \"turnmarker\") {\n        let ratio = ignoreRatio ? 1 : Settings.getRatio(marker_type);\n        let newX = 0;\n        let newY = 0;\n\n        switch (canvas.grid.type) {\n            case 2:\n            case 3: // Hex Rows\n                newX = token.center.x - ((token.h * ratio) / 2);\n                newY = token.center.y - ((token.h * ratio) / 2);\n                break;\n            case 4:\n            case 5: // Hex Columns\n                newX = token.center.x - ((token.w * ratio) / 2);\n                newY = token.center.y - ((token.w * ratio) / 2);\n                break;\n            default: // Gridless and Square\n                newX = token.center.x - ((this.getSmallerDimension(token.w, token.h) * ratio) / 2);\n                newY = token.center.y - ((this.getSmallerDimension(token.w, token.h) * ratio) / 2);\n        }\n\n        return {x: newX, y: newY};\n    }\n}","import { firstGM } from './utils.js';\nimport { Settings } from './settings.js';\n\nconst rotationDelta = 0.50; // How much to rotate by when the timer fires\nconst totalRotationTime = 60; // How long it should take for a full rotation by default.\n\n/**\n * Methods here can be called from all users, they will only be run once. This is ensured through checks against firstGM.\n */\nexport class MarkerAnimation {\n    /**\n     * Starts the animation loop for a certain type of marker\n     * @param {string} marker_type - type of marker to start animating\n     */\n    static startAnimation(marker_type) {\n        if (firstGM() === game.userId) {\n\n            if (!this.animators) {\n                this.animators = {};\n            }\n            if (marker_type in this.animators) {\n                return this.animators[marker_type];\n            }\n            this.animators[marker_type] = new Animator(marker_type);\n            return this.animators;\n        }\n    }\n\n    /**\n     * Stops the animation loop for a certain type of marker\n     * @param {string} marker_type - type of marker to stop animating\n     */\n    static stopAnimation(marker_type) {\n        if (firstGM() === game.userId) {\n            MarkerAnimation.startAnimation(marker_type); // Make sure something's there before we delete it.\n            if (this.animators) {\n                this.animators[marker_type].stopAnimation();\n                delete this.animators[marker_type];\n            }\n        }\n    }\n\n    /**\n     * Tells all currently running animators to stop their rotations. Then drops the table of animators.\n     */\n    static stopAllAnimation() {\n        if (firstGM() === game.userId) {\n            if (this.animators) {\n                for (const [, value] of Object.entries(this.animators)) {\n                    value.stopAnimation();\n                }\n                this.animators = {};\n            }\n        }\n    }\n}\n\nclass Animator {\n    /**\n     * Manages animating a specific set of markers. Construction begins animation.\n     * @param {string} marker_type - type of markers managed\n     */\n    constructor(marker_type) {\n        /**\n         * Speed forumla is such that a speed of 1 will rotate in the total rotation time.\n         * Lower speed values should slow the animation, and higher values should speed it up.\n         */\n        const base_update_freq = (360 / rotationDelta) / totalRotationTime; // In Hertz\n        const interval = (1 / (base_update_freq * Settings.getSpeed())) * 1000; // Hertz to seconds, account for speedup, and convert to milliseconds\n\n        this.marker_type = marker_type;\n        this.timeout = setInterval(this.rotateMarker.bind(this), interval);\n    }\n\n    /**\n     * Tell the interval timer to stop calling rotateMarker.\n     */\n    stopAnimation() {\n        clearInterval(this.timeout);\n    }\n\n    /**\n     * Rotate the marker. Called periodically by setInterval when the class is constructed.\n     */\n    async rotateMarker() {\n        let tile;\n        switch (this.marker_type) {\n            case \"deckmarker\":\n                tile = canvas.scene.tiles.find(t => t.flags?.deckMarker == true);\n                break;\n            case \"turnmarker\":\n            default:\n                tile = canvas.scene.tiles.find(t => t.flags?.turnMarker == true);\n                break;\n        }\n        try {\n            await tile.object.rotate(tile.rotation + rotationDelta, 0.001);\n        } catch (err) {\n            // If the tile has disappeared between finding it and trying to rotate it, it's probably been deleted.\n            // That's not a problem, so just fail silently.\n        }\n    }\n}","import {imageTitles, deckImageTitles, announcedActorOptions, Settings} from './settings.js';\nimport { modName } from './utils.js';\n\nconst videos = ['mp4', 'webm', 'ogg'];\n\nexport class SettingsForm extends FormApplication {\n\n    constructor(object, options = {}) {\n        super(object, options);\n    }\n\n    /**\n     * Default Options for this FormApplication\n     */\n    static get defaultOptions() {\n        return mergeObject(super.defaultOptions, {\n            id: 'turnmarker-settings-form',\n            title: 'Turn Marker - Global Settings',\n            template: `./modules/${modName}/templates/settings.html`,\n            classes: ['sheet', 'tm-settings'],\n            width: 500,\n            closeOnSubmit: true\n        });\n    }\n\n    getData() {\n        return {\n            turnMarkerEnabled: Settings.getIsEnabled(\"turnmarker\"),\n            ratio: Settings.getRatio(\"turnmarker\"),\n            image: this.getSelectList(imageTitles, Settings.getImageIndex(\"turnmarker\")),\n            customImage: Settings.getCustomImagePath(),\n            previewPath: Settings.getImagePath(),\n            // onDeck Marker Settings\n            onDeckMarkerEnabled: Settings.getIsEnabled(\"deckmarker\"),\n            deckRatio: Settings.getRatio(\"deckmarker\"),\n            deckImage: this.getSelectList(deckImageTitles, Settings.getImageIndex(\"deckmarker\")),\n            customDeckImage: Settings.getCustomDeckImagePath(),\n            onDeckPreviewPath: Settings.getOnDeckImagePath(),\n            onDeckPlayersOnly: Settings.getDeckPlayersOnly(),\n            // Announcement Settings\n            announceActors: this.getSelectList(announcedActorOptions, Settings.getAnnounceActors()),\n            announce: Settings.shouldAnnounceTurns(),\n            announceImage: Settings.getIncludeAnnounceImage(),\n            announceTokenName: Settings.getAnnounceTokenName(),\n            announceTurnMarkerAlias: Settings.getAnnounceTurnMarkerAlias(),\n            announcePlayerNames: Settings.getAnnouncePlayerNames(),\n            // Start Marker Settings\n            startMarkerEnabled: Settings.getIsEnabled(\"startmarker\"),\n            startMarkerPath: Settings.getStartMarkerPath()\n        };\n    }\n\n    /**\n     * Executes on form submission.\n     * @param {Object} e - the form submission event\n     * @param {Object} d - the form data\n     */\n    async _updateObject(e, d) {\n        console.log('Turn Marker | Saving Settings');\n        // Turnmarker settings\n        Settings.setRatio(d.ratio);\n        if (d.image) Settings.setImage(\"turnmarker\", d.image);\n        Settings.setCustomImagePath(d.customImage);\n        Settings.setIsEnabled(\"turnmarker\", d.turnMarkerEnabled);\n\n        // Announcement Settings\n        Settings.setShouldAnnounceTurns(d.announce);\n        Settings.setAnnounceActors(d.announceActors);\n        Settings.setIncludeAnnounceImage(d.announceImage);\n        Settings.setAnnounceTokenName(d.announceTokenName);\n        Settings.setAnnounceTurnMarkerAlias(d.announceTurnMarkerAlias);\n        Settings.setAnnouncePlayerNames(d.announcePlayerNames);\n        Settings.setIsEnabled(\"startmarker\", d.startMarkerEnabled);\n        Settings.setStartMarkerPath(d.startMarkerPath);\n\n        // Ondeck Marker Settings\n        Settings.setDeckRatio(d.deckRatio);\n        if (d.deckImage) Settings.setImage(\"deckmarker\", d.deckImage);\n        Settings.setCustomDeckImagePath(d.customDeckImage);\n        Settings.setIsEnabled(\"deckmarker\", d.onDeckMarkerEnabled);\n        Settings.setDeckPlayersOnly(d.onDeckPlayersOnly);\n    }\n\n    activateListeners(html) {\n        super.activateListeners(html);\n        const markerSelect = html.find('#image');\n        const customImage = html.find('#customImage');\n        const markerImgPreview = html.find('#markerImgPreview');\n\n        const onDeckMarkerSelect = html.find('#deckImage');\n        const customDeckImage = html.find('#customDeckImage');\n        const deckMarkerImgPreview = html.find('#onDeckMarkerImgPreview');\n\n        this.updatePreview(html);\n\n        if (markerSelect.length > 0) {\n            markerSelect.on('change', event => {\n                if (customImage[0].value.trim() == '') {\n                    markerImgPreview.attr('src', Settings.getImageByIndex(Number(event.target.value)));\n                }\n            });\n        }\n\n        if (onDeckMarkerSelect.length > 0) {\n            onDeckMarkerSelect.on('change', event => {\n                if (customDeckImage[0].value.trim() == '') {\n                    deckMarkerImgPreview.attr('src', Settings.getDeckImageByIndex(Number(event.target.value)));\n                }\n            });\n        }\n\n        if (customImage.length > 0) {\n            customImage.on('change', event => {\n                this.updatePreview(html);\n            });\n        }\n\n        if (customDeckImage.length > 0) {\n            customDeckImage.on('change', event => {\n                this.updatePreview(html);\n            });\n        }\n    }\n\n    updatePreview(html) {\n        this._updateTurnmarkerPreview(html);\n        this._updateOnDeckmarkerPreview(html);\n    }\n\n    /**\n     Updates turnmarker preview\n     **/\n    _updateTurnmarkerPreview(html) {\n        const markerSelect = html.find('#image');\n        const customImage = html.find('#customImage');\n        const markerImgPreview = html.find('#markerImgPreview');\n        const markerVideoPreview = html.find('#markerVideoPreview');\n\n        if (customImage[0].value.trim() == '') {\n            markerSelect[0].disabled = false;\n            markerImgPreview.attr('src', Settings.getImageByIndex(Number(markerSelect[0].value)));\n            markerImgPreview.removeClass('hidden');\n            markerVideoPreview.addClass('hidden');\n        } else {\n            markerSelect[0].disabled = true;\n            const ext = this.getExtension(customImage[0].value);\n            if (videos.includes(ext.toLowerCase())) {\n                markerVideoPreview.attr('src', customImage[0].value);\n                markerImgPreview.addClass('hidden');\n                markerVideoPreview.removeClass('hidden');\n            } else {\n                markerImgPreview.attr('src', customImage[0].value);\n                markerImgPreview.removeClass('hidden');\n                markerVideoPreview.addClass('hidden');\n            }\n        }\n    }\n\n    _updateOnDeckmarkerPreview(html) {\n        const onDeckMarkerSelect = html.find('#deckImage');\n        const customDeckImage = html.find('#customDeckImage');\n        const deckMarkerImgPreview = html.find('#onDeckMarkerImgPreview');\n        const deckMarkerVideoPreview = html.find('#onDeckMarkerVideoPreview');\n\n        if (customDeckImage[0].value.trim() == '') {\n            onDeckMarkerSelect[0].disabled = false;\n            deckMarkerImgPreview.attr('src', Settings.getDeckImageByIndex(Number(onDeckMarkerSelect[0].value)));\n            deckMarkerImgPreview.removeClass('hidden');\n            deckMarkerVideoPreview.addClass('hidden');\n        } else {\n            onDeckMarkerSelect[0].disabled = true;\n            const ext = this.getExtension(customDeckImage[0].value);\n            if (videos.includes(ext.toLowerCase())) {\n                deckMarkerVideoPreview.attr('src', customDeckImage[0].value);\n                deckMarkerImgPreview.addClass('hidden');\n                deckMarkerVideoPreview.removeClass('hidden');\n            } else {\n                deckMarkerImgPreview.attr('src', customDeckImage[0].value);\n                deckMarkerImgPreview.removeClass('hidden');\n                deckMarkerVideoPreview.addClass('hidden');\n            }\n        }\n    }\n\n    getExtension(filePath) {\n        return filePath.slice((filePath.lastIndexOf(\".\") - 1 >>> 0) + 2);\n    }\n\n    getSelectList(array, selected) {\n        let options = [];\n        array.forEach((x, i) => {\n            options.push({value: x, selected: i == selected});\n        });\n        return options;\n    }\n}\n","import {Marker} from './marker.js';\nimport {MarkerAnimation} from './markeranimation.js';\nimport {SettingsForm} from './settingsForm.js';\nimport {modName, getNextTurn} from './utils.js';\n\nconst version = 'tm-version';\nconst speed = 'speed';\nconst announce = 'announce-turn';\nconst announceActors = 'announce-Actors';\nconst announceImage = 'announce-image';\nconst announceTokenName = 'announce-token';\nconst announceTurnMarkerAlias = 'announce-turn-marker-alias';\nconst announcePlayerNames = 'announce-player-names';\n\n// Turn marker constants\nconst image = 'image';\nconst customimage = 'customimage';\nconst ratio = 'ratio';\nconst turnMarkerEnabled = 'turnmarker-enabled';\nconst animation = 'animation';\n\n// Ondeck marker constants\nconst onDeckMarkerEnabled = 'ondeckmarker-enabled';\nconst deckImage = 'deckimage';\nconst customDeckImage = 'customdeckimage';\nconst deckRatio = 'deckratio';\nconst deckAnimation = 'deckanimation';\nconst deckPlayersOnly = 'deckplayersonly';\n\nconst startMarkerEnabled = 'startMarker-enabled';\nconst startMarkerImage = 'startMarker-custom';\nexport const imageTitles = [\n    'Runes of Incendium by Rin',\n    'Runes of the Cultist by Rin',\n    'Runes of Regeneration by Rin',\n    'Runes of the Cosmos by Rin',\n    'Runes of Earthly Dust by Rin',\n    'Runes of Reality by Rin',\n    'Runes of the Believer by Rin',\n    'Runes of the Mad Mage by Rin',\n    'Runes of the Blue Sky by Rin',\n    'Runes of the Universe by Rin',\n    'Runes of Prosperity by Rin'\n];\n\nexport const deckImageTitles = [\n    'Runes of Prosperity by Rin',\n    'Runes of Incendium by Rin',\n    'Runes of the Cultist by Rin',\n    'Runes of Regeneration by Rin',\n    'Runes of the Cosmos by Rin',\n    'Runes of Earthly Dust by Rin',\n    'Runes of Reality by Rin',\n    'Runes of the Believer by Rin',\n    'Runes of the Mad Mage by Rin',\n    'Runes of the Blue Sky by Rin',\n    'Runes of the Universe by Rin'\n];\n\nexport const announcedActorOptions = [\n    'Announce for all',\n    'Announce for players',\n    'Announce for GM-controlled',\n    'Announce all but hide GM-controlled names'\n];\n\n/**\n * Provides functionality for reading and writing module settings\n */\nexport class Settings {\n\n    static getVersion() {\n        return game.settings.get(modName, version);\n    }\n\n    static setVersion(val) {\n        game.settings.set(modName, version, val);\n    }\n\n    /**\n     * Gets the image ratio given a marker_type\n     */\n    static getRatio(marker_type) {\n        switch (marker_type) {\n            case \"turnmarker\":\n                return game.settings.get(modName, ratio);\n            case \"deckmarker\":\n                return game.settings.get(modName, deckRatio);\n        }\n    }\n\n    /**\n     * Sets the turn marker image ratio\n     * @param {Number} val - The image ratio\n     */\n    static setRatio(val) {\n        game.settings.set(modName, ratio, val);\n    }\n\n    /**\n     * Sets the ondeck image ratio\n     * @param {Number} val - The image ratio\n     */\n    static setDeckRatio(val) {\n        game.settings.set(modName, deckRatio, val);\n    }\n\n    /**\n     * Returns true if the marker should be animated\n     */\n    static getShouldAnimate(marker_type) {\n        switch (marker_type) {\n            case \"turnmarker\":\n                return game.settings.get(modName, animation);\n            case \"deckmarker\":\n                return game.settings.get(modName, deckAnimation);\n        }\n\n    }\n\n    /**\n     * Gets the animation speed.\n     * @returns A speed multiplier, with 1 being the default.\n     */\n    static getSpeed() {\n        return game.settings.get(modName, speed);\n    }\n\n    /**\n     * Returns true if turn changes should be announced in chat\n     */\n    static shouldAnnounceTurns() {\n        return game.settings.get(modName, announce);\n    }\n\n    /**\n     * Sets whether or not to announce turn changes\n     * @param {Boolean} val - Whether or not to announce turn changes\n     */\n    static setShouldAnnounceTurns(val) {\n        game.settings.set(modName, announce, val);\n    }\n\n\n    /**\n     * Gets index of setting\n     * @returns {Number} - Index number of announced\n     */\n    static getAnnounceActors() {\n        return game.settings.get(modName, announceActors);\n    }\n\n    /**\n     * Sets who sees announced turn changes\n     * @param announceActors - which owners get units announcedActorOptions, which is selected.\n     */\n    static setAnnounceActors(val) {\n        return game.settings.set(modName, announceActors, val);\n    }\n\n    static getAnnounceTokenName() {\n        return game.settings.get(modName, announceTokenName);\n    }\n\n    static setAnnounceTokenName(val) {\n        return game.settings.set(modName, announceTokenName, val);\n    }\n\n    static getAnnounceTurnMarkerAlias() {\n        return game.settings.get(modName, announceTurnMarkerAlias);\n    }\n\n    static setAnnounceTurnMarkerAlias(val) {\n        return game.settings.set(modName, announceTurnMarkerAlias, val);\n    }\n\n    static getAnnouncePlayerNames() {\n        return game.settings.get(modName, announcePlayerNames);\n    }\n\n    static setAnnouncePlayerNames(val) {\n        return game.settings.set(modName, announcePlayerNames, val);\n    }\n    static getIncludeAnnounceImage() {\n        return game.settings.get(modName, announceImage);\n    }\n\n    static setIncludeAnnounceImage(val) {\n        game.settings.set(modName, announceImage, val);\n    }\n\n    /**\n     * Gets the index of the currently selected marker image\n     * @param {string} marker_type - Type of marker to get index for\n     */\n    static getImageIndex(marker_type) {\n        switch (marker_type) {\n            case \"turnmarker\":\n                return game.settings.get(modName, image);\n            case \"deckmarker\":\n                return game.settings.get(modName, deckImage);\n        }\n    }\n\n    static getStartMarker() {\n        if (game.settings.get(modName, startMarkerImage).trim() == '') {\n            return `modules/${modName}/assets/start.png`;\n        } else {\n            return game.settings.get(modName, startMarkerImage);\n        }\n    }\n\n    /**\n     * Gets the IsEnabled property of passed marker_type\n     * @param marker_type - Type of marker to check isEnabled\n     */\n    static getIsEnabled(marker_type) {\n        switch (marker_type) {\n            case \"turnmarker\":\n                return game.settings.get(modName, turnMarkerEnabled);\n            case \"deckmarker\":\n                return game.settings.get(modName, onDeckMarkerEnabled);\n            case \"startmarker\":\n                return game.settings.get(modName, startMarkerEnabled);\n        }\n    }\n\n    /**\n     * Sets the IsEnabled property of passed marker_type\n     * @param marker_type - Type of marker to check isEnabled\n     * @param val - boolean\n     */\n    static setIsEnabled(marker_type, val) {\n        switch (marker_type) {\n            case \"turnmarker\":\n                game.settings.set(modName, turnMarkerEnabled, val);\n                break;\n            case \"deckmarker\":\n                game.settings.set(modName, onDeckMarkerEnabled, val);\n                break;\n            case \"startmarker\":\n                game.settings.set(modName, startMarkerEnabled, val);\n                break;\n        }\n    }\n\n    static getStartMarkerPath() {\n        return game.settings.get(modName, startMarkerImage);\n    }\n\n    static setStartMarkerPath(val) {\n        game.settings.set(modName, startMarkerImage, val);\n    }\n\n    /**\n     * Gets a path to the currently selected image to be used as the marker\n     */\n    static getImagePath() {\n        if (game.settings.get(modName, customimage).trim() == '') {\n            return this.getImageByIndex(game.settings.get(modName, image));\n        } else {\n            return game.settings.get(modName, customimage);\n        }\n    }\n\n    /**\n     * Gets a path to the currently selected image to be used as the onDeck marker\n     */\n    static getOnDeckImagePath() {\n        if (game.settings.get(modName, customDeckImage).trim() == '') {\n            return this.getDeckImageByIndex(game.settings.get(modName, deckImage));\n        } else {\n            return game.settings.get(modName, customDeckImage);\n        }\n    }\n\n    static getImageByIndex(index) {\n        switch (index) {\n            case 0:\n                return `modules/${modName}/assets/incendium.png`;\n            case 1:\n                return `modules/${modName}/assets/cultist.png`;\n            case 2:\n                return `modules/${modName}/assets/regeneration.png`;\n            case 3:\n                return `modules/${modName}/assets/cosmos.png`;\n            case 4:\n                return `modules/${modName}/assets/earthlydust.png`;\n            case 5:\n                return `modules/${modName}/assets/reality.png`;\n            case 6:\n                return `modules/${modName}/assets/believer.png`;\n            case 7:\n                return `modules/${modName}/assets/madmage.png`;\n            case 8:\n                return `modules/${modName}/assets/bluesky.png`;\n            case 9:\n                return `modules/${modName}/assets/universe.png`;\n            case 10:\n                return `modules/${modName}/assets/prosperity.png`;\n        }\n    }\n\n    /**\n     * Gets on deck marker image path\n     */\n    static getDeckImageByIndex(index) {\n        switch (index) {\n            case 0:\n                return `modules/${modName}/assets/prosperity.png`;\n            case 1:\n                return `modules/${modName}/assets/incendium.png`;\n            case 2:\n                return `modules/${modName}/assets/cultist.png`;\n            case 3:\n                return `modules/${modName}/assets/regeneration.png`;\n            case 4:\n                return `modules/${modName}/assets/cosmos.png`;\n            case 5:\n                return `modules/${modName}/assets/earthlydust.png`;\n            case 6:\n                return `modules/${modName}/assets/reality.png`;\n            case 7:\n                return `modules/${modName}/assets/believer.png`;\n            case 8:\n                return `modules/${modName}/assets/madmage.png`;\n            case 9:\n                return `modules/${modName}/assets/bluesky.png`;\n            case 10:\n                return `modules/${modName}/assets/universe.png`;\n        }\n    }\n\n    static setImage(image_type, val) {\n        switch (image_type) {\n            case \"turnmarker\":\n                game.settings.set(modName, image, val);\n                break;\n            case \"deckmarker\":\n                game.settings.set(modName, deckImage, val);\n                break;\n        }\n\n    }\n\n    static getCustomImagePath() {\n        return game.settings.get(modName, customimage);\n    }\n\n    static setCustomImagePath(val) {\n        game.settings.set(modName, customimage, val);\n    }\n\n    /**\n     * Gets on deck marker image path\n     */\n    static getCustomDeckImagePath() {\n        return game.settings.get(modName, customDeckImage);\n    }\n\n    /**\n     * Sets ondeck marker image path\n     * @param val - path to desired image.\n     */\n    static setCustomDeckImagePath(val) {\n        game.settings.set(modName, customDeckImage, val);\n    }\n\n    /**\n     * Gets if deck markers only used for players\n     */\n    static getDeckPlayersOnly() {\n        return game.settings.get(modName, deckPlayersOnly);\n    }\n\n    /**\n     * Sets if deck markers only used for players\n     * @param val - boolean\n     */\n    static setDeckPlayersOnly(val) {\n        game.settings.set(modName, deckPlayersOnly, val);\n    }\n\n\n    /**\n     * Registers all game settings\n     */\n    static registerSettings() {\n\n        game.settings.registerMenu(modName, 'tm.settingsMenu', {\n            name: 'tm.settings.button.name',\n            label: 'tm.settings.button.label',\n            icon: 'fas fa-sync-alt',\n            type: SettingsForm,\n            restricted: true\n        });\n\n        game.settings.register(modName, version, {\n            name: `${modName} version`,\n            default: '0.0.0',\n            type: String,\n            scope: 'world'\n        });\n\n        game.settings.register(modName, ratio, {\n            name: 'tm.settings.ratio.name',\n            hint: 'tm.settings.ratio.hint',\n            scope: 'world',\n            config: false,\n            type: Number,\n            default: 1.5,\n            restricted: true\n        });\n\n        game.settings.register(modName, animation, {\n            name: 'tm.settings.animate.name',\n            hint: 'tm.settings.animate.hint',\n            scope: 'user',\n            config: true,\n            type: Boolean,\n            default: true,\n            onChange: shouldAnimate => {\n                if (!game.paused && shouldAnimate && canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags.turnMarker === true)) {\n                    MarkerAnimation.startAnimation(\"turnmarker\");\n                } else {\n                    MarkerAnimation.stopAnimation(\"turnmarker\");\n                }\n            }\n        });\n\n        game.settings.register(modName, deckAnimation, {\n            name: 'tm.settings.deckAnimate.name',\n            hint: 'tm.settings.deckAnimate.hint',\n            scope: 'user',\n            config: true,\n            type: Boolean,\n            default: true,\n            onChange: shouldAnimate => {\n                if (!game.paused && shouldAnimate && canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.data.flags.deckMarker === true)) {\n                    MarkerAnimation.startAnimation(\"deckmarker\");\n                } else {\n                    MarkerAnimation.stopAnimation(\"deckmarker\");\n                }\n            }\n        });\n\n        game.settings.register(modName, speed, {\n            name: 'tm.settings.speed.name',\n            hint: 'tm.settings.speed.hint',\n            scope: 'user',\n            config: true,\n            type: Number,\n            default: 1\n        });\n\n        game.settings.register(modName, image, {\n            name: 'tm.settings.image.name',\n            scope: 'world',\n            config: false,\n            type: Number,\n            default: 0,\n            choices: imageTitles,\n            restricted: true,\n            onChange: value => Marker.updateImagePath(value)\n        });\n\n        // OnDeck Marker Settings\n        game.settings.register(modName, deckRatio, {\n            name: 'tm.settings.deckRatio.name',\n            hint: 'tm.settings.deckRatio.hint',\n            scope: 'world',\n            config: false,\n            type: Number,\n            default: 1.5,\n            restricted: true\n        });\n\n        game.settings.register(modName, deckImage, {\n            name: 'tm.settings.deckImage.name',\n            scope: 'world',\n            config: false,\n            type: Number,\n            default: 0,\n            choices: deckImageTitles,\n            restricted: true,\n            onChange: value => Marker.updateOnDeckImagePath(value)\n        });\n\n        game.settings.register(modName, customDeckImage, {\n            name: 'tm.settings.customDeckImage.name',\n            hint: 'tm.settings.customDeckImage.hint',\n            scope: 'world',\n            config: false,\n            type: String,\n            default: '',\n            restricted: true,\n            onChange: value => Marker.updateOnDeckImagePath(value)\n        });\n\n        game.settings.register(modName, onDeckMarkerEnabled, {\n            name: 'tm.settings.onDeckMarkerEnabled.name',\n            hint: 'tm.settings.onDeckMarkerEnabled.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: false,\n            restricted: true,\n            onChange: enabled => {\n                if (!enabled) {\n                    Marker.deleteOnDeckMarker();\n                } else if (game.combat && game.combat.combatant && game.combat.started) {\n                    let nextTurn = getNextTurn(game.combat);\n                    Marker.placeOnDeckMarker(game.combat.turns[nextTurn].token.id);\n                }\n            }\n        });\n\n        game.settings.register(modName, deckPlayersOnly, {\n            name: 'tm.settings.deckPlayersOnly.name',\n            hint: 'tm.settings.deckPlayersOnly.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: true,\n            restricted: true\n        });\n\n        // Announcements\n        game.settings.register(modName, announceActors, {\n            name: 'tm.settings.announcedActors.name',\n            hint: 'tm.settings.announcedActors.hint',\n            scope: 'world',\n            config: false,\n            type: Number,\n            default: 0,\n            restricted: true,\n            choices: announcedActorOptions\n        });\n\n        game.settings.register(modName, announceTokenName, {\n            name: 'tm.settings.announceTokenName.name',\n            hint: 'tm.settings.announceTokenName.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: false,\n            restricted: true\n        });\n\n        game.settings.register(modName, announceTurnMarkerAlias, {\n          name: 'tm.settings.announceTurnMarkerAlias.name',\n          hint: 'tm.settings.announceTurnMarkerAlias.hint',\n          scope: 'world',\n          config: false,\n          type: Boolean,\n          default: false,\n          restricted: true\n        });\n\n        game.settings.register(modName, announcePlayerNames, {\n          name: 'tm.settings.announcePlayerNames.name',\n          hint: 'tm.settings.announcePlayerNames.hint',\n          scope: 'world',\n          config: false,\n          type: Boolean,\n          default: true,\n          restricted: true\n        });\n\n        game.settings.register(modName, customimage, {\n            name: 'tm.settings.customImage.name',\n            hint: 'tm.settings.customImage.hint',\n            scope: 'world',\n            config: false,\n            type: String,\n            default: '',\n            restricted: true,\n            onChange: value => Marker.updateImagePath(value)\n        });\n\n        game.settings.register(modName, announce, {\n            name: 'tm.settings.announce.name',\n            hint: 'tm.settings.announce.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: true\n        });\n\n        game.settings.register(modName, announceImage, {\n            name: 'tm.settings.announceImage.name',\n            hint: 'tm.settings.announceImage.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: true\n        });\n\n        game.settings.register(modName, turnMarkerEnabled, {\n            name: 'tm.settings.turnMarkerEnabled.name',\n            hint: 'tm.settings.turnMarkerEnabled.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: true,\n            restricted: true,\n            onChange: enabled => {\n                if (!enabled) {\n                    Marker.deleteTurnMarker();\n                } else if (game.combat && game.combat.combatant && game.combat.started) {\n                    Marker.placeTurnMarker(game.combat.combatant.token.id);\n                }\n            }\n        });\n\n        game.settings.register(modName, startMarkerEnabled, {\n            name: 'tm.settings.startEnabled.name',\n            hint: 'tm.settings.startEnabled.hint',\n            scope: 'world',\n            config: false,\n            type: Boolean,\n            default: false,\n            restricted: true,\n            onChange: enabled => {\n                if (!enabled) {\n                    Marker.deleteStartMarker();\n                } else if (game.combat && game.combat.combatant && game.combat.started) {\n                    Marker.placeStartMarker(game.combat.combatant.token.id);\n                }\n            }\n        });\n\n        game.settings.register(modName, startMarkerImage, {\n            name: 'tm.settings.startImage.name',\n            hint: 'tm.settings.startImage.hint',\n            scope: 'world',\n            config: false,\n            type: String,\n            default: '',\n            restricted: true\n        });\n    }\n}\n","import { Settings } from \"./settings.js\";\n\nexport class Chatter {\n\n    static sendTurnMessage(combatant, hideNPC_name=false) {\n        const announceLabel = game.i18n.localize(\"tm.announceLabel\");\n        let combatantName = combatant.actor.name;\n        let aliasName = combatantName;\n        if (Settings.getAnnounceTokenName()) {\n            combatantName = combatant.token.name;\n            aliasName = combatant.name;\n        }\n\n        let announceText;\n        if (Settings.getAnnounceTurnMarkerAlias()) {\n            aliasName = announceLabel;\n            announceText = \"\";\n        } else {\n            announceText = `<em>${announceLabel}</em>`;\n        }\n\n        let playerNameDisplay;\n        if (Settings.getAnnouncePlayerNames()) {\n          let players = [];\n          combatant.players.forEach(player => {\n              players.push(player.name);\n          });\n          if (players.length == 0) players.push(\"GM\");\n          playerNameDisplay = `<p>${players.join(' - ')}</p>`;\n        } else {\n          playerNameDisplay = \"\";\n        }\n\n        if (hideNPC_name && !combatant.actor.hasPlayerOwner) {\n            combatantName = \"???\";\n        }\n\n        ChatMessage.create({\n            speaker: { actor: combatant.actor, alias: aliasName },\n            //speaker: { actor: {}, alias: 'Turn Marker' },\n            content:\n                `<div class=\"flexrow\">${this.placeImage(combatant)}\n                    <div style=\"flex: 12;\">\n                        <h2>${combatantName}'s Turn</h2>\n                        ${playerNameDisplay}\n                    </div>\n                    </div>${announceText}`\n        });\n    }\n\n    static placeImage(combatant) {\n        if (Settings.getIncludeAnnounceImage()) {\n            let img = combatant.img;\n            if (combatant.actor.img) {\n                img = combatant.actor.img;\n            }\n            return `<div style=\"flex:3;padding-right:4px\"><img src=\"${img}\" style=\"border: none;\" /></div>`;\n        } else return '';\n    }\n}\n","import {Chatter} from './chatter.js';\nimport {Marker} from './marker.js';\nimport {MarkerAnimation} from './markeranimation.js';\nimport {Settings} from './settings.js';\nimport {renderUpdateWindow} from './updateWindow.js';\nimport {deleteTile, firstGM, socketName, getNextTurn, modName} from './utils.js';\n\n\nlet lastTurn = '';\n\nHooks.once('init', () => {\n    Settings.registerSettings();\n});\n\nHooks.once('ready', async () => {\n    if (game.user.isGM) {\n        if (isNewerVersion(game.modules.get(modName).version, Settings.getVersion())) {\n            renderUpdateWindow();\n        }\n    }\n\n    game.socket.on(socketName, async (data) => {\n        if (game.user.isGM) {\n            if (data.mode) {\n                deleteTile({ mode: data.mode });\n            }\n        }\n    });\n\n    if (game.user.isGM) {\n        // Clean up any leftover markers before start, and remake since sometimes tiles get desync'd it seems\n        await Marker.clearAllMarkers();\n        if (game.combat) {\n            handleCombatUpdate(game.combat, true);\n        }\n    }\n    if (!game.paused) {\n        const tiles = canvas.scene.getEmbeddedCollection('Tile');\n        if (Settings.getShouldAnimate('turnmarker') && tiles?.find(t => t.flags?.turnMarker === true)) {\n            MarkerAnimation.startAnimation('turnmarker');\n        }\n        if (Settings.getShouldAnimate('deckmarker') && tiles?.find(t => t.flags?.deckMarker === true)) {\n            MarkerAnimation.startAnimation('deckmarker');\n        }\n    }\n});\n\nHooks.on('updateCombat', async (combat, update) => {\n    // Clear out any leftovers, there seems to be a buggy instance where updateCombat is fired, when combat isn't\n    // started nor, is a turn changed\n    if (!combat.started) {\n        await Marker.clearAllMarkers();\n    }\n    // SWADE has a special initiative\n    if (game.system.id != \"swade\") {\n        handleCombatUpdate(combat, update);\n    }\n});\n\n// For SWADE, need to reget active player after each round, but no better hook is fired after initiative shuffle\nHooks.on(\"renderCombatTracker\", async (combatTracker, update) => {\n    if (game.system.id == \"swade\") {\n        handleCombatUpdate(combatTracker.viewed, update)\n    }\n});\n\nHooks.on('deleteCombat', async () => {\n    await Marker.clearAllMarkers();\n    MarkerAnimation.stopAllAnimation();\n});\n\nHooks.on('updateToken', async (tokenDoc, updateData, diff, id) => {\n    /*\n     Moving preUpdateToken logic here, since pre hooks induce race conditions\n     */\n\n    // Do onDeck first, so current token will have higher Z-index\n    const tiles = canvas.scene.getEmbeddedCollection('Tile');\n    let tile = tiles?.find(t => t.flags?.deckMarker == true);\n    if (tile) {\n        if ((updateData.x || updateData.y || updateData.width || updateData.height || updateData.hidden) && game.combat && game.user.isGM && game.userId === firstGM()) {\n            const nextTurn = getNextTurn(game.combat);\n            const nextToken = game.combat.turns[nextTurn].token;\n            await Marker.moveMarkerToToken(nextToken.id, tile.id, 'deckmarker');\n        }\n    }\n\n    tile = tiles?.find(t => t.flags?.turnMarker == true);\n    if (tile) {\n        if ((updateData.x || updateData.y || updateData.width || updateData.height || updateData.hidden) && game.combat?.combatant?.token.id === updateData._id && game.user.isGM && game.userId === firstGM()) {\n            await Marker.moveMarkerToToken(updateData._id, tile.id, 'turnmarker');\n        }\n    }\n});\n\nfunction isVisible(tile) {\n    if (tile.hidden) {\n        return game.user.isGM;\n    }\n\n    if (!canvas.scene.tokenVision) {\n        return true;\n    }\n\n    if (tile._controlled) {\n        return true;\n    }\n\n    const combatant = canvas.scene.tokens.find(t => t.id === game.combat?.combatant.token.id);\n\n    if (!combatant || combatant.hidden) {\n        return game.user.isGM;\n    }\n\n    let marker_type = \"turnmarker\";\n    if (tile.flags.startMarker) {\n        marker_type = \"startmarker\";\n    } else if (tile.flags.deckMarker) {\n        marker_type = \"deckmarker\";\n    }\n\n    const ratio = Settings.getRatio(marker_type);\n    const w = tile.width / ratio;\n    const h = tile.height / ratio;\n    const tolerance = Math.min(w, h) / 4;\n\n    return canvas.effects.visibility.testVisibility(tile.center, {tolerance, object: tile});\n}\n\nasync function createCombatDeckMarker(combat) {\n    const nextTurn = getNextTurn(combat);\n    if (Settings.getDeckPlayersOnly()) {\n        if (combat.turns[nextTurn].actor.hasPlayerOwner) {\n            await Marker.placeOnDeckMarker(combat.turns[nextTurn].token.id).then(function () {\n                if (!game.paused && Settings.getShouldAnimate(\"deckmarker\")) {\n                    MarkerAnimation.startAnimation(\"deckmarker\");\n                }\n            });\n        } else {\n            await Marker.deleteOnDeckMarker();\n        }\n    } else {\n        await Marker.placeOnDeckMarker(combat.turns[nextTurn].token.id).then(function () {\n            if (!game.paused && Settings.getShouldAnimate(\"deckmarker\")) {\n                MarkerAnimation.startAnimation(\"deckmarker\");\n            }\n        });\n    }\n}\n\nasync function handleCombatUpdate(combat, update) {\n    if (combat.combatant) {\n        if (update && lastTurn != combat.combatant.id && game.user.isGM && game.userId == firstGM()) {\n            if (combat && combat.combatant && combat.started) {\n                lastTurn = combat.combatant.id;\n                await Marker.placeStartMarker(combat.combatant.token.id);\n                await createCombatDeckMarker(combat);\n                await Marker.placeTurnMarker(combat.combatant.token.id).then(function () {\n                    if (!game.paused && Settings.getShouldAnimate(\"turnmarker\")) {\n                        MarkerAnimation.startAnimation(\"turnmarker\");\n                    }\n                });\n                if (Settings.shouldAnnounceTurns() && !combat.combatant.hidden) {\n                    switch (Settings.getAnnounceActors()) {\n                        case 0:\n                            Chatter.sendTurnMessage(combat.combatant);\n                            break;\n                        case 1:\n                            if (combat.combatant.actor.hasPlayerOwner) {\n                                Chatter.sendTurnMessage(combat.combatant);\n                            }\n                            break;\n                        case 2:\n                            if (!combat.combatant.actor.hasPlayerOwner) {\n                                Chatter.sendTurnMessage(combat.combatant);\n                            }\n                            break;\n                        case 3:\n                            Chatter.sendTurnMessage(combat.combatant, true);\n                    }\n                }\n            }\n        }\n    }\n}\n\nHooks.on('updateTile', (tileDoc) => {\n    if (tileDoc.flags?.turnMarker || tileDoc.flags?.startMarker || tileDoc.flags?.deckMarker) {\n        const tile = canvas.scene.tiles.find(t => t.id === tileDoc.id);\n        if (tile) {\n            tile.renderable = isVisible(tile);\n        }\n    }\n});\n\nHooks.on('sightRefresh', () => {\n    for (const tile of canvas.scene.tiles) {\n        if (tile.flags?.turnMarker || tile.flags?.startMarker || tile.flags?.deckMarker) {\n            tile.renderable = isVisible(tile);\n        }\n    }\n});\n\nHooks.on('pauseGame', (isPaused) => {\n    if (!isPaused) {\n        if (Settings.getShouldAnimate(\"turnmarker\") && canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags?.turnMarker === true)) {\n            MarkerAnimation.startAnimation(\"turnmarker\");\n        }\n        if (Settings.getShouldAnimate(\"deckmarker\") && canvas.scene.getEmbeddedCollection('Tile')?.find(t => t.flags?.deckMarker === true)) {\n            MarkerAnimation.startAnimation(\"deckmarker\");\n        }\n    } else {\n        MarkerAnimation.stopAllAnimation();\n    }\n});\n","import { Settings } from './settings.js';\nimport { modName } from './utils.js';\n\nexport function renderUpdateWindow() {\n    const module = game.modules.get(modName);\n\n    if (!isNewerVersion(module.version, Settings.getVersion()))\n        return;\n\n    class UpdateWindow extends Application {\n        static get defaultOptions() {\n            return mergeObject(super.defaultOptions, {\n                template: `modules/${module.id}/templates/updateWindow.html`,\n                resizable: false,\n                width: 500,\n                height: 600,\n                classes: [\"updateWindow\"],\n                title: `${module.title} - Updated`\n            });\n        }\n\n        getData() {\n            return {\n                version: module.version\n            };\n        }\n\n        activateListeners(html) {\n            super.activateListeners(html);\n\n            html.find('.show-again').on('change', ev => {\n                Settings.setVersion(ev.currentTarget.checked ? module.version : null);\n            });\n        }\n    }\n\n    new UpdateWindow().render(true);\n}"],"names":["modName","socketName","findTokenById","tokenId","canvas","tokens","ownedTokens","find","t","id","firstGM","user","game","users","contents","role","CONST","USER_ROLES","GAMEMASTER","active","getNextTurn","combat","turn","turns","length","async","deleteTile","mode","tiles","scene","getEmbeddedCollection","filter","flags","startMarker","map","deleteEmbeddedDocuments","turnMarker","deckMarker","Marker","static","isGM","socket","emit","Settings","getIsEnabled","token","dims","this","getImageDimensions","center","getImageLocation","tile","updateData","img","getImagePath","width","w","height","h","x","y","z","rotation","hidden","locked","createEmbeddedDocuments","updateEmbeddedDocuments","_id","deleteTurnMarker","getOnDeckImagePath","deleteOnDeckMarker","getStartMarker","deleteStartMarker","markerId","marker_type","update","ratio","getRatio","newWidth","newHeight","grid","type","getSmallerDimension","newX","newY","MarkerAnimation","userId","animators","Animator","startAnimation","stopAnimation","value","Object","entries","constructor","interval","getSpeed","timeout","setInterval","rotateMarker","bind","clearInterval","object","rotate","err","videos","SettingsForm","FormApplication","super","defaultOptions","mergeObject","title","template","classes","closeOnSubmit","getData","turnMarkerEnabled","image","getSelectList","imageTitles","getImageIndex","customImage","getCustomImagePath","previewPath","onDeckMarkerEnabled","deckRatio","deckImage","deckImageTitles","customDeckImage","getCustomDeckImagePath","onDeckPreviewPath","onDeckPlayersOnly","getDeckPlayersOnly","announceActors","announcedActorOptions","getAnnounceActors","announce","shouldAnnounceTurns","announceImage","getIncludeAnnounceImage","announceTokenName","getAnnounceTokenName","announceTurnMarkerAlias","getAnnounceTurnMarkerAlias","announcePlayerNames","getAnnouncePlayerNames","startMarkerEnabled","startMarkerPath","getStartMarkerPath","e","d","console","log","setRatio","setImage","setCustomImagePath","setIsEnabled","setShouldAnnounceTurns","setAnnounceActors","setIncludeAnnounceImage","setAnnounceTokenName","setAnnounceTurnMarkerAlias","setAnnouncePlayerNames","setStartMarkerPath","setDeckRatio","setCustomDeckImagePath","setDeckPlayersOnly","activateListeners","html","markerSelect","markerImgPreview","onDeckMarkerSelect","deckMarkerImgPreview","updatePreview","on","event","trim","attr","getImageByIndex","Number","target","getDeckImageByIndex","_updateTurnmarkerPreview","_updateOnDeckmarkerPreview","markerVideoPreview","disabled","removeClass","addClass","ext","getExtension","includes","toLowerCase","deckMarkerVideoPreview","filePath","slice","lastIndexOf","array","selected","options","forEach","i","push","version","speed","customimage","animation","deckAnimation","deckPlayersOnly","startMarkerImage","settings","get","val","set","index","image_type","registerMenu","name","label","icon","restricted","register","default","String","scope","hint","config","Boolean","onChange","shouldAnimate","paused","data","choices","updateImagePath","updateOnDeckImagePath","enabled","combatant","started","nextTurn","placeOnDeckMarker","placeTurnMarker","placeStartMarker","Chatter","hideNPC_name","announceLabel","i18n","localize","announceText","playerNameDisplay","combatantName","actor","aliasName","players","player","join","hasPlayerOwner","ChatMessage","create","speaker","alias","content","placeImage","lastTurn","isVisible","tokenVision","_controlled","tolerance","Math","min","effects","visibility","testVisibility","handleCombatUpdate","then","getShouldAnimate","createCombatDeckMarker","sendTurnMessage","Hooks","once","registerSettings","isNewerVersion","modules","getVersion","module","UpdateWindow","Application","resizable","ev","setVersion","currentTarget","checked","render","renderUpdateWindow","clearAllMarkers","system","combatTracker","viewed","stopAllAnimation","tokenDoc","diff","nextToken","moveMarkerToToken","tileDoc","renderable","isPaused"],"sourceRoot":""}